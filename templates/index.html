<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Crypto Status</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='14' fill='%230f172a'/%3E%3Ctext x='32' y='42' font-size='32' text-anchor='middle' fill='%23facc15'%3E%E2%82%BF%3C/text%3E%3C/svg%3E"
    />
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        --accent: #ffb703;
      }

      body {
        margin: 0;
        padding: clamp(1rem, 3vw, 2.5rem);
        background: #0f172a;
        color: #e2e8f0;
      }

      h1,
      h2 {
        margin: 0;
        font-size: 2rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: min(1400px, 100%);
        margin: 0 auto;
        box-sizing: border-box;
      }

      .card {
        background: #1e293b;
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 25px rgba(15, 23, 42, 0.4);
        width: 100%;
      }

      .device-header {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
      }

      th {
        text-align: left;
        font-size: 0.9rem;
        color: #94a3b8;
        font-weight: 500;
      }

      td {
        padding: 0.75rem 0 0.75rem 0;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .price {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .change {
        font-weight: 600;
      }

      .change.positive {
        color: #4ade80;
      }

      .change.negative {
        color: #fb7185;
      }

      .meta {
        display: flex;
        gap: 1rem;
        align-items: center;
        color: #94a3b8;
        font-size: 0.9rem;
      }

      .chart-wrapper {
        width: 100%;
        height: clamp(220px, 35vh, 360px);
        margin-top: 1.5rem;
        position: relative;
      }

      .chart-mini {
        margin-top: 0.75rem;
      }

      .chart-label {
        font-size: 0.8rem;
        color: #cbd5f5;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .chart-wrapper.mini-chart {
        height: clamp(150px, 28vh, 220px);
        margin-top: 0.35rem;
        border: 1px dashed rgba(148, 163, 184, 0.3);
        border-radius: 0.65rem;
        padding: 0.35rem;
        background: rgba(15, 23, 42, 0.35);
      }

      .status-legend {
        display: none;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.65rem;
        margin-top: 0.5rem;
        color: #cbd5f5;
        font-size: 0.9rem;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.35rem 0.6rem;
        border-radius: 0.5rem;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.3);
      }

      .legend-swatch {
        width: 14px;
        height: 14px;
        border-radius: 0.35rem;
        border: 1px solid rgba(148, 163, 184, 0.5);
      }

      .legend-swatch.offline {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(248, 113, 113, 0.8);
      }

      .legend-swatch.power {
        background: rgba(148, 163, 184, 0.25);
        border-color: rgba(148, 163, 184, 0.8);
      }

      .metrics-group {
        margin-top: 1.25rem;
        padding: 1rem;
        border-radius: 0.75rem;
        background: rgba(15, 23, 42, 0.45);
        border: 1px solid rgba(148, 163, 184, 0.18);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .highlight {
        margin-top: 1.5rem;
        padding: 1.25rem;
        border-radius: 0.75rem;
        background: linear-gradient(120deg, rgba(248, 4, 33, 0.25), rgba(15, 23, 42, 0.65));
        border: 1px solid rgba(248, 4, 33, 0.35);
      }

      .highlight .label {
        font-size: 0.85rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: #fecdd3;
        margin-bottom: 0.35rem;
      }

      .highlight .value {
        font-size: 2rem;
        font-weight: 700;
        color: #f8fafc;
      }

      .sub-highlight {
        margin-top: 0.9rem;
        padding: 0.9rem 1rem;
        border-radius: 0.65rem;
        background: rgba(248, 113, 113, 0.12);
        border: 1px solid rgba(248, 113, 113, 0.3);
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #fecdd3;
        font-size: 0.95rem;
      }

      .sub-highlight .label {
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-size: 0.7rem;
        color: #f9a8d4;
      }

      .sub-highlight .value {
        font-weight: 700;
        color: #fef2f2;
      }

      .quote-card {
        background: #0b1220;
        border: 1px solid rgba(148, 163, 184, 0.25);
        color: #e2e8f0;
        padding: 1.4rem;
        border-radius: 0.85rem;
        box-shadow: 0 8px 22px rgba(10, 17, 30, 0.45);
        width: 100%;
      }

      .quote-title {
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: 0.9rem;
        color: #93c5fd;
        margin-bottom: 0.55rem;
      }

      .quote-text {
        font-size: 1.15rem;
        line-height: 1.6;
        color: #f8fafc;
      }

      .metric-row {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        font-size: 0.85rem;
        color: #cbd5f5;
      }

      .metric-row .label {
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #94a3b8;
        font-size: 0.65rem;
      }

      .metric-row .value {
        font-weight: 600;
        font-size: 0.9rem;
      }

      .error {
        margin-top: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        background: rgba(251, 113, 133, 0.15);
        color: #fecdd3;
      }

      .plots-grid {
        margin-top: 1.1rem;
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1rem;
        width: 100%;
      }

      .plot-card {
        background: #0b1220;
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 0.7rem;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .plot-card img {
        width: 100%;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: #0f172a;
      }

      .plot-title {
        font-weight: 700;
        color: #e2e8f0;
      }

      .plot-meta {
        font-size: 0.85rem;
        color: #94a3b8;
      }

      .table-scroll {
        width: 100%;
        overflow-x: auto;
      }

      .table-scroll table {
        min-width: 640px;
      }

      @media (max-width: 640px) {
        h1 {
          font-size: 1.6rem;
        }

        h2 {
          font-size: 1.2rem;
        }

        .meta {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  </head>
  <body>
    <div class="stack">
      <section class="card">
        <h1>Markets and stocks</h1>
        <div class="meta">
          <div>
            Last update:
            <span id="updated-at">{{ updated_at }}</span>
          </div>
        </div>

        <div id="error" class="error" style="display: none"></div>

        <div class="table-scroll">
          <table>
            <thead>
              <tr>
                <th>Asset</th>
                <th>Price (USD)</th>
                <th>Change 24h</th>
                <th>Change 7d</th>
                <th>Change 30d</th>
              </tr>
            </thead>
            <tbody id="prices-body"></tbody>
          </table>
        </div>
      </section>

      <section class="card" id="device-card" style="display: none">
        <div class="device-header">
          <h2 id="device-title">AxeOS</h2>
          <div id="device-subtitle" class="meta"></div>
        </div>
        <div id="device-highlight" class="highlight" style="display: none">
          <div class="label" id="highlight-label"></div>
          <div class="value" id="highlight-value"></div>
        </div>
        <div class="sub-highlight" id="session-highlight" style="display: none">
          <div class="label" id="session-highlight-label"></div>
          <div class="value" id="session-highlight-value"></div>
        </div>
        <div class="metrics-group" id="device-metrics"></div>
      </section>

      <section class="card" id="pi-card" style="display: none">
        <div class="device-header">
          <h2 id="pi-title">Raspberry Pi</h2>
          <div id="pi-subtitle" class="meta"></div>
        </div>
        <div id="pi-highlight" class="highlight" style="display: none">
          <div class="label" id="pi-highlight-label"></div>
          <div class="value" id="pi-highlight-value"></div>
        </div>
        <div class="chart-wrapper" id="pi-chart-wrapper" style="display: none">
          <canvas id="pi-chart"></canvas>
        </div>
        <div class="chart-mini" id="pi-full-chart-container" style="display: none">
          <div class="chart-label">Full history</div>
          <div class="chart-wrapper mini-chart">
            <canvas id="pi-full-chart"></canvas>
          </div>
        </div>
        <div class="status-legend" id="pi-status-legend">
          <div class="legend-item" id="legend-offline">
            <span class="legend-swatch offline"></span>
            <span>Sin internet</span>
          </div>
          <div class="legend-item" id="legend-power">
            <span class="legend-swatch power"></span>
            <span>Sin tensión / script detenido</span>
          </div>
        </div>
        <div class="metrics-group" id="pi-metrics"></div>
      </section>

      <section class="quote-card" id="quote-card" style="display: none">
        <div class="quote-title">Quote of the day — A Course in Miracles</div>
        <div class="quote-text" id="quote-text"></div>
      </section>

      <section class="card" id="port-block-card" style="display: none">
        <div class="device-header">
          <h2>UFW blocks</h2>
          <div id="port-block-subtitle" class="meta"></div>
        </div>
        <div id="port-block-plots" class="plots-grid"></div>
        <div id="port-block-error" class="error" style="display: none"></div>
      </section>
    </div>

    <script>
      const initialData = {{ initial_data | tojson }};
      const initialError = {{ initial_error | tojson }};
      const initialSystem = {{ initial_system | tojson }};
      const initialPi = {{ initial_pi | tojson }};
      const initialPiHistory = {{ initial_pi_history | tojson }};
      const initialPiHistoryFull = {{ initial_pi_history_full | tojson }};
      const initialQuote = {{ initial_quote | tojson }};
      const initialPortBlock = {{ initial_port_block | tojson }};
      const authToken = new URLSearchParams(window.location.search).get("token");
      const pricesBody = document.getElementById("prices-body");
      const errorBox = document.getElementById("error");
      const updatedAt = document.getElementById("updated-at");
      const quoteCard = document.getElementById("quote-card");
      const quoteText = document.getElementById("quote-text");
      const deviceCard = document.getElementById("device-card");
      const deviceTitle = document.getElementById("device-title");
      const deviceSubtitle = document.getElementById("device-subtitle");
      const deviceMetrics = document.getElementById("device-metrics");
      const deviceHighlight = document.getElementById("device-highlight");
      const highlightLabel = document.getElementById("highlight-label");
      const highlightValue = document.getElementById("highlight-value");
      const sessionHighlight = document.getElementById("session-highlight");
      const sessionHighlightLabel = document.getElementById("session-highlight-label");
      const sessionHighlightValue = document.getElementById("session-highlight-value");
      const piCard = document.getElementById("pi-card");
      const piTitle = document.getElementById("pi-title");
      const piSubtitle = document.getElementById("pi-subtitle");
      const piMetrics = document.getElementById("pi-metrics");
      const piHighlight = document.getElementById("pi-highlight");
      const piHighlightLabel = document.getElementById("pi-highlight-label");
      const piHighlightValue = document.getElementById("pi-highlight-value");
      const piChartWrapper = document.getElementById("pi-chart-wrapper");
      const piChartCanvas = document.getElementById("pi-chart");
      const piFullChartContainer = document.getElementById("pi-full-chart-container");
      const piFullChartCanvas = document.getElementById("pi-full-chart");
      const piStatusLegend = document.getElementById("pi-status-legend");
      const legendOffline = document.getElementById("legend-offline");
      const legendPower = document.getElementById("legend-power");
      const portBlockCard = document.getElementById("port-block-card");
      const portBlockSubtitle = document.getElementById("port-block-subtitle");
      const portBlockPlots = document.getElementById("port-block-plots");
      const portBlockError = document.getElementById("port-block-error");
      const PORT_BLOCK_REFRESH_MS = 15 * 60 * 1000;
      let piChart = null;
      let piFullChart = null;

      const STATUS_COLORS = {
        offline: "rgba(239, 68, 68, 0.18)",
        power: "rgba(148, 163, 184, 0.18)",
      };

      const formatter = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 2,
      });

      function formatChange(value) {
        return Number.isFinite(value) ? `${value.toFixed(2)}%` : "—";
      }

      function changeClass(value) {
        if (!Number.isFinite(value)) return "";
        return value >= 0 ? "positive" : "negative";
      }

      const statusOverlayPlugin = {
        id: "statusOverlay",
        beforeDatasetsDraw(chart) {
          const overlay = chart.$statusOverlays;
          if (!overlay) return;
          const { ctx, chartArea, scales } = chart;
          if (!ctx || !chartArea || !scales?.x) return;
          const top = chartArea.top;
          const bottom = chartArea.bottom;
          ctx.save();

          const drawSpan = (span, color) => {
            if (!span?.start || !span?.end) return;
            const startX = scales.x.getPixelForValue(span.start);
            const endX = scales.x.getPixelForValue(span.end);
            if (!Number.isFinite(startX) || !Number.isFinite(endX)) return;
            const left = Math.min(startX, endX);
            const width = Math.abs(endX - startX);
            if (width < 2) return;
            ctx.fillStyle = color;
            ctx.fillRect(left, top, width, bottom - top);
          };

          (overlay.powerSpans || []).forEach((span) => drawSpan(span, STATUS_COLORS.power));
          (overlay.offlineSpans || []).forEach((span) => drawSpan(span, STATUS_COLORS.offline));
          ctx.restore();
        },
      };

      Chart.register(statusOverlayPlugin);

      function median(values) {
        if (!Array.isArray(values) || !values.length) return null;
        const sorted = [...values].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) {
          return (sorted[mid - 1] + sorted[mid]) / 2;
        }
        return sorted[mid];
      }

      function computeExpectedIntervalMs(points) {
        if (!Array.isArray(points) || points.length < 2) return 60000;
        const gaps = [];
        for (let i = 1; i < points.length; i += 1) {
          const delta = points[i].x - points[i - 1].x;
          if (Number.isFinite(delta) && delta > 0) {
            gaps.push(delta);
          }
        }
        const med = median(gaps);
        if (Number.isFinite(med) && med > 0) return med;
        return 60000;
      }

      function buildPowerSpans(points, expectedMs) {
        if (!Array.isArray(points) || points.length < 2) return [];
        const spans = [];
        const threshold = Math.max(expectedMs * 2.5, expectedMs + 90000);
        for (let i = 1; i < points.length; i += 1) {
          const gap = points[i].x - points[i - 1].x;
          if (gap > threshold) {
            spans.push({ start: points[i - 1].x, end: points[i].x });
          }
        }
        return spans;
      }

      function buildOfflineSpans(points, expectedMs) {
        if (!Array.isArray(points) || !points.length) return [];
        const spans = [];
        let currentStart = null;
        for (let i = 0; i < points.length; i += 1) {
          const online = points[i].online;
          if (online === false && !currentStart) {
            currentStart = points[i].x;
          }
          if ((online !== false || i === points.length - 1) && currentStart) {
            const end =
              online === false && i === points.length - 1
                ? new Date(points[i].x.getTime() + expectedMs)
                : points[i].x;
            spans.push({ start: currentStart, end });
            currentStart = null;
          }
        }
        return spans;
      }

      function buildStatusOverlay(points) {
        if (!Array.isArray(points) || !points.length) {
          return { offlineSpans: [], powerSpans: [] };
        }
        const expectedMs = computeExpectedIntervalMs(points);
        return {
          offlineSpans: buildOfflineSpans(points, expectedMs),
          powerSpans: buildPowerSpans(points, expectedMs),
        };
      }

      function applyStatusOverlay(chart, overlay) {
        if (!chart) return;
        chart.$statusOverlays = overlay;
      }

      function updateStatusLegend(overlay) {
        if (!piStatusLegend) return;
        const hasOffline = overlay?.offlineSpans?.length;
        const hasPower = overlay?.powerSpans?.length;
        if (hasOffline || hasPower) {
          piStatusLegend.style.display = "flex";
          if (legendOffline) {
            legendOffline.style.opacity = hasOffline ? "1" : "0.55";
          }
          if (legendPower) {
            legendPower.style.opacity = hasPower ? "1" : "0.55";
          }
        } else {
          piStatusLegend.style.display = "none";
        }
      }

      function cacheBustedUrl(url, version) {
        const params = [];
        if (authToken) params.push(`token=${encodeURIComponent(authToken)}`);
        if (version) params.push(`v=${encodeURIComponent(version)}`);
        if (!params.length) return url;
        const separator = url.includes("?") ? "&" : "?";
        return `${url}${separator}${params.join("&")}`;
      }

      function renderQuote(quotePayload) {
        const text = quotePayload?.text;
        if (text) {
          quoteCard.style.display = "block";
          quoteText.textContent = text;
        } else {
          quoteCard.style.display = "none";
          quoteText.textContent = "";
        }
      }

      function renderPortBlock(portBlock) {
        if (!portBlock) {
          portBlockCard.style.display = "none";
          return;
        }

        const subtitleParts = [];
        if (portBlock.updated_at) {
          const updated = new Date(portBlock.updated_at);
          if (!Number.isNaN(updated.getTime())) {
            subtitleParts.push(`Updated ${updated.toLocaleString()}`);
          }
        }
        portBlockSubtitle.textContent = subtitleParts.join(" • ");
        portBlockSubtitle.style.display = subtitleParts.length ? "block" : "none";

        const plots = Array.isArray(portBlock.plots) ? portBlock.plots : [];
        portBlockPlots.innerHTML = "";
        if (plots.length) {
          portBlockPlots.style.display = "grid";
          portBlockPlots.style.gridTemplateColumns = "minmax(0, 1fr)";
          portBlockPlots.style.gap = "1rem";
          plots.forEach((plot) => {
            const wrapper = document.createElement("div");
            wrapper.className = "plot-card";
            const title = document.createElement("div");
            title.className = "plot-title";
            title.textContent = plot.label || plot.filename || "Plot";
            const img = document.createElement("img");
            const version = plot.updated_at || portBlock.updated_at || "";
            img.src = cacheBustedUrl(plot.url, version);
            img.alt = plot.label || plot.filename || "Plot";
            const meta = document.createElement("div");
            meta.className = "plot-meta";
            const versionDate = version ? new Date(version) : null;
            meta.textContent =
              versionDate && !Number.isNaN(versionDate.getTime())
                ? `Updated ${versionDate.toLocaleString()}`
                : "";
            wrapper.appendChild(title);
            wrapper.appendChild(img);
            if (meta.textContent) {
              wrapper.appendChild(meta);
            }
            portBlockPlots.appendChild(wrapper);
          });
        } else {
          portBlockPlots.style.display = "none";
        }

        const errorText = portBlock.error;
        if (errorText) {
          portBlockError.style.display = "block";
          portBlockError.textContent = errorText;
        } else {
          portBlockError.style.display = "none";
          portBlockError.textContent = "";
        }

        const hasContent = plots.length || errorText;
        portBlockCard.style.display = hasContent ? "block" : "none";
      }

      function renderRows(items) {
        pricesBody.innerHTML = "";
        items.forEach((item) => {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${item.name}</td>
            <td class="price">${
              item.price === null || item.price === undefined
                ? "—"
                : formatter.format(item.price)
            }</td>
            <td class="change ${changeClass(item.change)}">${formatChange(item.change)}</td>
            <td class="change ${changeClass(item.change_7d)}">${formatChange(item.change_7d)}</td>
            <td class="change ${changeClass(item.change_30d)}">${formatChange(item.change_30d)}</td>
          `;
          pricesBody.appendChild(row);
        });
      }

      function renderMetricsCard(data, elements) {
        const {
          card,
          titleEl,
          subtitleEl,
          metricsEl,
          highlightEl,
          highlightLabelEl,
          highlightValueEl,
          subHighlightEl,
          subHighlightLabelEl,
          subHighlightValueEl,
          subHighlightKey,
          defaultTitle,
          formatSubtitle,
        } = elements;
        const hasMetrics = Array.isArray(data?.metrics) && data.metrics.length > 0;
        const hasHighlight = !!(data?.highlight && data.highlight.value);
        const subHighlight = subHighlightKey ? data?.[subHighlightKey] : null;

        if (!hasMetrics && !hasHighlight) {
          card.style.display = "none";
          if (metricsEl) metricsEl.innerHTML = "";
          if (subHighlightEl) subHighlightEl.style.display = "none";
          return;
        }

        card.style.display = "block";
        const meta = data?.meta || {};
        if (titleEl) {
          titleEl.textContent = meta.hostname || defaultTitle;
        }
        if (subtitleEl) {
          const subtitle = formatSubtitle ? formatSubtitle(meta) : "";
          subtitleEl.textContent = subtitle;
          subtitleEl.style.display = subtitle ? "block" : "none";
        }

        if (highlightEl) {
          if (data?.highlight && data.highlight.value) {
            highlightEl.style.display = "block";
            if (highlightLabelEl) {
              highlightLabelEl.textContent = data.highlight.label || "";
            }
            if (highlightValueEl) {
              highlightValueEl.textContent = data.highlight.value;
            }
          } else {
            highlightEl.style.display = "none";
          }
        }

        if (subHighlightEl) {
          if (subHighlight && subHighlight.value) {
            subHighlightEl.style.display = "flex";
            if (subHighlightLabelEl) {
              subHighlightLabelEl.textContent = subHighlight.label || "";
            }
            if (subHighlightValueEl) {
              subHighlightValueEl.textContent = subHighlight.value;
            }
          } else {
            subHighlightEl.style.display = "none";
          }
        }

        if (metricsEl) {
          metricsEl.innerHTML = "";
          (data?.metrics || []).forEach((metric) => {
            const row = document.createElement("div");
            row.className = "metric-row";
            row.innerHTML = `
              <span class="label">${metric.label}</span>
              <span class="value">${metric.value}</span>
            `;
            metricsEl.appendChild(row);
          });
        }
      }

      function renderSystem(system) {
        renderMetricsCard(system, {
          card: deviceCard,
          titleEl: deviceTitle,
          subtitleEl: deviceSubtitle,
          metricsEl: deviceMetrics,
          highlightEl: deviceHighlight,
          highlightLabelEl: highlightLabel,
          highlightValueEl: highlightValue,
          subHighlightEl: sessionHighlight,
          subHighlightLabelEl: sessionHighlightLabel,
          subHighlightValueEl: sessionHighlightValue,
          subHighlightKey: "session_highlight",
          defaultTitle: "AxeOS",
          formatSubtitle(meta) {
            const parts = [];
            if (meta.model) parts.push(meta.model);
            if (meta.ip) parts.push(meta.ip);
            return parts.join(" • ");
          },
        });
      }

      function renderPi(pi) {
        renderMetricsCard(pi, {
          card: piCard,
          titleEl: piTitle,
          subtitleEl: piSubtitle,
          metricsEl: piMetrics,
          highlightEl: piHighlight,
          highlightLabelEl: piHighlightLabel,
          highlightValueEl: piHighlightValue,
          defaultTitle: "Raspberry Pi",
          formatSubtitle() {
            return "";
          },
        });
      }

      function normalizeHistory(history) {
        const safe = history || {};
        const length = safe.labels?.length || 0;
        const points = [];
        for (let i = 0; i < length; i += 1) {
          const label = safe.labels[i];
          if (!label) continue;
          const onlineRaw = Array.isArray(safe.online) ? safe.online[i] : undefined;
          const online =
            onlineRaw === true ? true : onlineRaw === false ? false : onlineRaw === 0 ? false : null;
          points.push({
            x: new Date(label),
            temperature: safe.temperature?.[i] ?? null,
            cpu: safe.cpu?.[i] ?? null,
            ram: safe.ram?.[i] ?? null,
            fan: safe.fan?.[i] ?? null,
            online,
          });
        }
        return points;
      }

      function buildPiSeries(points) {
        return {
          labels: points.map((point) => point.x),
          tempData: points.map((point) => ({ x: point.x, y: point.temperature })),
          cpuData: points.map((point) => ({ x: point.x, y: point.cpu })),
          ramData: points.map((point) => ({ x: point.x, y: point.ram })),
          fanData: points.map((point) => ({ x: point.x, y: point.fan })),
        };
      }

      function createPiDatasets(series) {
        return [
          {
            label: "Temp (°C)",
            data: series.tempData,
            borderColor: "#fb923c",
            backgroundColor: "rgba(251, 146, 60, 0.2)",
            yAxisID: "temp",
            spanGaps: true,
            tension: 0.3,
          },
          {
            label: "CPU (%)",
            data: series.cpuData,
            borderColor: "#0ea5e9",
            backgroundColor: "rgba(14, 165, 233, 0.2)",
            yAxisID: "percent",
            spanGaps: true,
            tension: 0.3,
          },
          {
            label: "RAM (%)",
            data: series.ramData,
            borderColor: "#22c55e",
            backgroundColor: "rgba(34, 197, 94, 0.2)",
            yAxisID: "percent",
            spanGaps: true,
            tension: 0.3,
          },
          {
            label: "Fan (%)",
            data: series.fanData,
            borderColor: "#f472b6",
            backgroundColor: "rgba(244, 114, 182, 0.2)",
            yAxisID: "percent",
            spanGaps: true,
            tension: 0.3,
          },
        ];
      }

      function updatePiChart(history) {
        if (!piChartCanvas || !piChartWrapper) return;
        const points = normalizeHistory(history);
        if (!points.length) {
          piChartWrapper.style.display = "none";
          if (piChart) {
            piChart.data.labels = [];
            piChart.data.datasets.forEach((dataset) => (dataset.data = []));
            applyStatusOverlay(piChart, { offlineSpans: [], powerSpans: [] });
            piChart.update("none");
          }
          updateStatusLegend({ offlineSpans: [], powerSpans: [] });
          return;
        }

        piChartWrapper.style.display = "block";
        const series = buildPiSeries(points);
        const datasets = createPiDatasets(series);
        const overlay = buildStatusOverlay(points);

        if (!piChart) {
          const ctx = piChartCanvas.getContext("2d");
          piChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: series.labels,
              datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: "index",
                intersect: false,
              },
              plugins: {
                legend: {
                  labels: { color: "#cbd5f5" },
                },
              },
              scales: {
                x: {
                  type: "time",
                  time: { tooltipFormat: "HH:mm", displayFormats: { minute: "HH:mm" } },
                  ticks: { color: "#94a3b8" },
                  grid: { color: "rgba(148, 163, 184, 0.2)" },
                },
                temp: {
                  type: "linear",
                  position: "left",
                  title: { display: true, text: "°C", color: "#94a3b8" },
                  ticks: { color: "#94a3b8" },
                  grid: { color: "rgba(148, 163, 184, 0.2)" },
                },
                percent: {
                  type: "linear",
                  position: "right",
                  min: 0,
                  max: 100,
                  title: { display: true, text: "%", color: "#94a3b8" },
                  ticks: { color: "#94a3b8" },
                  grid: { drawOnChartArea: false },
                },
              },
            },
          });
          applyStatusOverlay(piChart, overlay);
          piChart.update("none");
        } else {
          piChart.data.labels = series.labels;
          piChart.data.datasets.forEach((dataset, idx) => {
            dataset.data = datasets[idx].data;
          });
          applyStatusOverlay(piChart, overlay);
          piChart.update("none");
        }
        updateStatusLegend(overlay);
      }

      function updatePiFullChart(history) {
        if (!piFullChartCanvas || !piFullChartContainer) return;
        const labels = Array.isArray(history?.labels) ? history.labels : [];
        if (!labels.length) {
          piFullChartContainer.style.display = "none";
          if (piFullChart) {
            piFullChart.data.labels = [];
            piFullChart.data.datasets.forEach((dataset) => (dataset.data = []));
            applyStatusOverlay(piFullChart, { offlineSpans: [], powerSpans: [] });
            piFullChart.update("none");
          }
          return;
        }
        if (piFullChart && piFullChart.data?.labels) {
          const lastIncoming = labels[labels.length - 1];
          const lastChart = piFullChart.data.labels[piFullChart.data.labels.length - 1];
          const lastIncomingTs = lastIncoming ? new Date(lastIncoming).getTime() : null;
          const lastChartTs =
            lastChart instanceof Date ? lastChart.getTime() : new Date(lastChart).getTime();
          if (
            lastIncomingTs &&
            lastChartTs &&
            labels.length === piFullChart.data.labels.length &&
            lastIncomingTs === lastChartTs
          ) {
            piFullChartContainer.style.display = "block";
            return;
          }
        }

        const points = normalizeHistory(history);
        if (!points.length) {
          piFullChartContainer.style.display = "none";
          if (piFullChart) {
            piFullChart.data.labels = [];
            piFullChart.data.datasets.forEach((dataset) => (dataset.data = []));
            piFullChart.update("none");
          }
          return;
        }

        piFullChartContainer.style.display = "block";
        const series = buildPiSeries(points);
        const datasets = createPiDatasets(series);
        const overlay = buildStatusOverlay(points);

        if (!piFullChart) {
          const ctx = piFullChartCanvas.getContext("2d");
          piFullChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: series.labels,
              datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false,
              parsing: false,
              interaction: {
                mode: "nearest",
                intersect: false,
              },
              elements: {
                point: { radius: 0 },
              },
              plugins: {
                legend: {
                  labels: { color: "#cbd5f5", boxWidth: 12 },
                },
                decimation: {
                  enabled: true,
                  algorithm: "lttb",
                  samples: 300,
                },
              },
              scales: {
                x: {
                  type: "time",
                  time: { displayFormats: { hour: "dd HH:mm" } },
                  ticks: { color: "#94a3b8" },
                  grid: { color: "rgba(148, 163, 184, 0.15)" },
                },
                temp: {
                  type: "linear",
                  position: "left",
                  title: { display: true, text: "°C", color: "#94a3b8" },
                  ticks: { color: "#94a3b8" },
                  grid: { color: "rgba(148, 163, 184, 0.15)" },
                },
                percent: {
                  type: "linear",
                  position: "right",
                  min: 0,
                  max: 100,
                  title: { display: true, text: "%", color: "#94a3b8" },
                  ticks: { color: "#94a3b8" },
                  grid: { drawOnChartArea: false },
                },
              },
            },
          });
          applyStatusOverlay(piFullChart, overlay);
          piFullChart.update("none");
        } else {
          piFullChart.data.labels = series.labels;
          piFullChart.data.datasets.forEach((dataset, idx) => {
            dataset.data = datasets[idx].data;
          });
          applyStatusOverlay(piFullChart, overlay);
          piFullChart.update("none");
        }
      }

      function renderError(message) {
        if (message) {
          errorBox.style.display = "block";
          errorBox.textContent = message;
        } else {
          errorBox.style.display = "none";
          errorBox.textContent = "";
        }
      }

      async function refresh() {
        try {
          const query = authToken ? `?token=${encodeURIComponent(authToken)}` : "";
          const response = await fetch(`/api/prices${query}`);
          const payload = await response.json();

          if (!response.ok) {
            throw new Error(payload.error || "Unknown error");
          }

          renderRows(payload.data || []);
          renderSystem(payload.system);
          renderPi(payload.pi);
          updatePiChart(payload.pi_history);
          updatePiFullChart(payload.pi_history_full);
          renderQuote(payload.quote);
          renderError(payload.error || "");
          updatedAt.textContent = new Date(payload.updated_at).toLocaleTimeString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          });
        } catch (err) {
          renderError(err.message);
        }
      }

      async function refreshPortBlock() {
        try {
          const query = authToken ? `?token=${encodeURIComponent(authToken)}` : "";
          const response = await fetch(`/api/port-block${query}`);
          const payload = await response.json();
          if (!response.ok) {
            throw new Error(payload.error || payload.port_block?.error || "Unknown error");
          }
          renderPortBlock(payload.port_block);
        } catch (err) {
          if (portBlockError) {
            portBlockError.style.display = "block";
            portBlockError.textContent = err.message;
          }
        }
      }

      renderRows(initialData || []);
      renderSystem(initialSystem);
      renderPi(initialPi);
      updatePiChart(initialPiHistory);
      updatePiFullChart(initialPiHistoryFull);
      renderQuote(initialQuote);
      renderPortBlock(initialPortBlock);
      renderError(initialError);

      refresh();
      setInterval(refresh, 10000);
      setInterval(refreshPortBlock, PORT_BLOCK_REFRESH_MS);
      refreshPortBlock();
    </script>
  </body>
</html>
